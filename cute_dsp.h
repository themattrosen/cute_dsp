/*
	------------------------------------------------------------------------------
		Licensing information can be found at the end of the file.
	------------------------------------------------------------------------------

	cute_dsp.h - v1.0

	To create implementation (the function definitions)
		#define CUTE_DSP_IMPLEMENTATION
	in *one* C/CPP file (translation unit) that includes this file
	For more details on integration with cute_sound, read the README.md

	Summary:
		cute_dsp is a C API for various DSP effects suitable for video games and
		meant to interface directly with the cute_sound library created by Randy Gaul.
		The scope of cute_dsp will eventually include:

		-lowpass filter
		-highpass filter
		-white noise injection
		-lowpass filtering with resonances
		-wind noise presets for resonant filters
		-realtime reverb
		-echo filter
		-randomization settings
		-filter presets

	Revision history:
		1.0		(05/25/2019)	initial release: added lowpass and highpass implementation
		1.1		(06/29/2019)	added internal memory pool, dsp context and mixers to be used by cute_sound
		1.2		(07/12/2019)	bug fixes from integration testing
		1.3 	(09/02/2019)	added cute_sound plugin interface
		1.4		(02/26/2020)	added echo filter plugin
		1.5		(05/24/2021)	added noise generator plugin
*/
#ifndef CUTE_SOUND_H
#	error Please include cute_sound.h before including cute_dsp.h.
#endif

#if !defined(CUTE_DSP_H)

/* BEGIN PLUGIN INTERFACE FUNCTIONS */
/*
	Helper function to create a plugin interface for the lowpass filter
	Called internally, but exposed for use if needed.
*/
cs_plugin_interface_t cd_make_lowpass_plugin();

/*
	Helper function to create a plugin interface for the lowpass filter.
	Called internally, but exposed for use if needed.
*/
cs_plugin_interface_t cd_make_highpass_plugin();

/*
	Helper function to create a plugin interface for the echo filter.
	Called internally, but exposed for use if needed.
*/
cs_plugin_interface_t cd_make_echo_plugin();

/*
	Helper function to create a plugin interface for the noise generator.
	Called internally, but exposed for use if needed.
*/
cs_plugin_interface_t cd_make_noise_plugin();
/* END PLUGIN INTERFACE FUNCTIONS */

/* BEGIN FORWARD DECLARATIONS */
/*
	cute_dsp context type
	Manages memory and settings of the cute_dsp context.
*/
struct cd_context_t;
typedef struct cd_context_t cd_context_t;

/*
	cute_dsp lowpass filter type. 
	Implemented using a second order (6dB/Octave roll off) Butterworth filter.
*/
struct cd_lowpass_t;
typedef struct cd_lowpass_t cd_lowpass_t;

/*
	cute_dsp highpass filter type
	Implemented using a second order (6dB/Octave roll off) Butterworth filter
		converted from the second order Butterworth lowpass transfer function.
*/
struct cd_highpass_t;
typedef struct cd_highpass_t cd_highpass_t;

/*
	cute_dsp echo filter type
	Implemented using a ring buffer.
	Designable parameters:
		delay    - echo delay time in seconds
		mix      - mix factor of the loudness of the echoes
		feedback - amount that the echoes feed back into each other
*/
struct cd_echo_t;
typedef struct cd_echo_t cd_echo_t;

/*
	cute_dsp noise generator type
	Implemented using white noise generated by 
	an xorshift128 PRNG.
	Designable parameters:
		amplitude_db   - mix of the noise in decibels. keeps gain updated.
		amplitude_gain - mix of the noise in linear gain. keeps db updated.
*/
struct cd_noise_t;
typedef struct cd_noise_t cd_noise_t;

#define CUTE_DSP_MAX_FRAME_LENGTH (4096)
#define CUTE_DSP_DEFAULT_ECHO_MAX_DELAY (0.5f)
#define CUTE_DSP_NOISE_INAUDIBLE (-96.f)

/* END FORWARD DECLARATIONS */

/* BEGIN DSP CONTEXT API */

typedef struct cd_context_def_t
{
	unsigned playing_pool_count; // max number of playing sounds
	float sampling_rate;

	// bit field for setting what plugins to use
	struct
	{
		unsigned int use_lowpass : 1;
		unsigned int use_highpass : 1;
		unsigned int use_echo : 1;
		unsigned int use_noise : 1;
	};

	// optional parameters
	float echo_max_delay_s;	// set to 0 to use default of 0.5s
	size_t rand_seed;
} cd_context_def_t;

/*
	Allocatees the singleton dsp context that manages memory for all the filters.
*/
cd_context_t* cd_make_context(cs_context_t* sound_ctx, cd_context_def_t def);

/*
	Releases all the memory associated with cute_dsp.
*/
void cd_release_context(cd_context_t** context);

/* END DSP CONTEXT API */

/* BEGIN LOW PASS FILTER API */

/*
	Constructs a lowpass filter from the dsp context's memory pool.
	Initialized with cutoff frequency 20000Hz so its effects are inaudible 
	unless you call cd_set_lowpass_cutoff(playing_sound, hz).
*/
cd_lowpass_t* cd_make_lowpass_filter(cd_context_t* context);

/*
	releases memory of the lowpass filter and sets to NULL
*/
void cd_release_lowpass(cd_context_t* context, cd_lowpass_t** filter);

/*
	Sets the cutoff frequency in a lowpass filter, and updates the filter coefficients.
	Cutoff frequency parameter is in samples per second.
	Calls cd_set_lowpass_cutoff_frequency_radians with the converted value
*/
void cd_set_lowpass_cutoff_frequency(cd_lowpass_t* filter, float cutoff_freq_in_hz);

/*
	Fetches lowpass filter from playing sound and calls cd_set_lowpass_cutoff_frequency.
*/
void cd_set_lowpass_cutoff(cs_playing_sound_t* playing_sound, float cutoff_freq_in_hz);

/*
	Gets the cutoff frequency in a lowpass filter.
	Cutoff frequency parameter in hz.
*/
float cd_get_lowpass_cutoff_frequency(const cd_lowpass_t* filter);

/*
	Gets the cutoff frequency in a lowpass filter.
	Cutoff frequency parameter in hz.
*/
float cd_get_lowpass_cutoff(const cs_playing_sound_t* playing_sound);

/*
	Processes the next audio frame using the given lowpass filter.
*/
void cd_sample_lowpass(cd_context_t* context, cd_lowpass_t* filter, const float* input, float** output, unsigned num_samples);
/* END LOWPASS FILTER API */

/* BEGIN HIGHPASS FILTER API */
/*
	Constructs a highpass filter from the dsp context's memory pool.
	Initialized with cutoff frequency 20Hz so its effects are inaudible 
	unless you call cd_set_highpass_cutoff(playing_sound, hz).
*/
cd_highpass_t* cd_make_highpass_filter(cd_context_t* context);

/*
	releases memory of the highpass filter and sets to NULL
*/
void cd_release_highpass(cd_context_t* context, cd_highpass_t** filter);

/*
	Sets the cutoff frequency in a highpass filter, and updates the filter coefficients.
	Cutoff frequency parameter is in samples per second.
	Calls cd_set_highpass_cutoff_frequency_radians with the converted value
*/
void cd_set_highpass_cutoff_frequency(cd_highpass_t* filter, float cutoff_freq_in_hz);

/*
	Fetches lowpass filter from playing sound and calls cd_set_lowpass_cutoff_frequency.
*/
void cd_set_highpass_cutoff(cs_playing_sound_t* playing_sound, float cutoff_freq_in_hz);

/*
	Gets the cutoff frequency in a highpass filter.
	Cutoff frequency parameter in hz.
*/
float cd_get_highpass_cutoff_frequency(const cd_highpass_t* filter);

/*
	Gets the cutoff frequency in a highpass filter.
	Cutoff frequency parameter in hz.
*/
float cd_get_highpass_cutoff(const cs_playing_sound_t* playing_sound);

/*
	Processes the next audio frame with the given highpass filter
*/
void cd_sample_highpass(cd_context_t* context, cd_highpass_t* filter, const float* input, float** output, unsigned num_samples);

/* END HIGHPASS FILTER API */

/* BEGIN ECHO FILTER API */
/*
	Constructs an echo filter from the dsp context's memory pool.
	Echo filters have two ring buffers that are both dynamically allocated, 
		which can cause cache misses in the audio thread.
*/
cd_echo_t* cd_make_echo_filter(cd_context_t* context);

/*
	Releases memory for echo ring buffers, adds echo filter back to the
		context memory pool.
*/
void cd_release_echo_filter(cd_context_t* context, cd_echo_t** filter);

/*
	Sets the delay time of the echo filter.
	Limited by the max delay set as a parameter in the context.
		Max delay can be retrieved via cd_get_echo_max_delay(playing_sound);
	@param t
		Delay time in seconds.
*/
void cd_set_echo_delay(cs_playing_sound_t* playing_sound, float t);

/*
	Sets the mix factor of the echo filter.
	Effectively is the loudness of the delayed samples.
	@param a
		Delay mix factor. Generally between 0 and 1.
*/
void cd_set_echo_mix(cs_playing_sound_t* playing_sound, float a);

/*
	Sets the feedback factor of the echo filter.
	Effectively is the amount that the echoes will echo on themselves.
	@param b
		Feedback factor. Generally between 0 and 1.
*/
void cd_set_echo_feedback(cs_playing_sound_t* playing_sound, float b);

/*
	@return 
		Retrieves the max delay time for echo filters.
*/
float cd_get_echo_max_delay(const cs_playing_sound_t* playing_sound);

/*
	@return
		Retrieves the delay time for the given filter in seconds.
*/
float cd_get_echo_delay(const cs_playing_sound_t* playing_sound);

/*
	@return
		Retrieves the echo filter's delay mix factor.
*/
float cd_get_echo_mix(const cs_playing_sound_t* playing_sound);

/*
	@return
		Retrieves the echo filter's feedback factor
*/
float cd_get_echo_feedback(const cs_playing_sound_t* playing_sound);

/*
	Processes the next audio frame with the given echo filter.
*/
void cd_sample_echo(cd_context_t* context, cd_echo_t* filter, const float* input, float** output, unsigned num_samples);

/* END ECHO FILTER API */

/* BEGIN NOISE GENERATOR API */
/*
	Constructs a noise generator filter from the dsp context's memory pool.
	Initialized with an amplitude of 0 gain so its effects are inaudible
	unless you call cd_set_noise_amplitude_db or cd_set_noise_amplitude_gain.
*/
cd_noise_t* cd_make_noise_generator(cd_context_t* context);

/*
	releases memory of the noise generator and sets to NULL.
*/
void cd_release_noise(cd_context_t* context, cd_noise_t** filter);

/*
	Fetches noise generator from playing sound and sets noise amplitude in decibels.
*/
void cd_set_noise_amplitude_db(cs_playing_sound_t* playing_sound, float db);

/*
	Fetches noise generator from playing sound and sets noise amplitude in linear gain.
*/
void cd_set_noise_amplitude_gain(cs_playing_sound_t* playing_sound, float gain);

/*
	Gets the noise amplitude in decibels.
*/
float cd_get_noise_amplitude_db(const cs_playing_sound_t* playing_sound);

/*
	Gets the noise amplitude in linear gain.
*/
float cd_get_noise_amplitude_gain(const cs_playing_sound_t* playing_sound);

/*
	Processes the next audio frame with the given noise generator
*/
void cd_sample_noise(cd_context_t* context, cd_noise_t* filter, const float* input, float** output, unsigned num_samples);

/* END NOISE GENERATOR API */
#define CUTE_DSP_H
#endif
/* END HEADER SECTION */
/**********************************************************************************************/

/**********************************************************************************************/
/* BEGIN IMPLEMENTATION SECTION */
#ifdef CUTE_DSP_IMPLEMENTATION
#ifndef CUTE_DSP_IMPLEMENTATION_ONCE
#define CUTE_DSP_IMPLEMENTATION_ONCE

/* HELPER MACROS */
#if !defined(CUTE_DSP_ALLOC)
	#include <stdlib.h> // malloc, free
	#include <string.h> // memcpy, memset
	#define CUTE_DSP_ALLOC(size, mem_ctx) malloc(size)
	#define CUTE_DSP_FREE(mem, mem_ctx)   free(mem)
#endif

#define CUTE_DSP_ASSERT_INTERNAL *(int*)0 = 0
#define CUTE_DSP_ASSERT(X) do { if(!(X)) CUTE_DSP_ASSERT_INTERNAL; } while (0)

#if !defined(CUTE_DSP_MATH)
	#include <math.h> // sinf, cosf, absf, atan2f
	#define CUTE_DSP_MATH
	#define CUTE_DSP_SIN(angle_rad) (sinf(angle_rad))
	#define CUTE_DSP_COS(angle_rad) (cosf(angle_rad))
	#define CUTE_DSP_ABS(val)       (fabsf(val))
	#define CUTE_DSP_PI				(3.1415926f)
	#define CUTE_DSP_SQRT_2 		(1.4142136f)
	#define CUTE_DSP_CLAMP(val, least, most) ( (val) < (least) ? (least) : ( (val) > (most) ? (most) : (val) ) )
	#define CUTE_DSP_LERP_FLOAT(start, end, factor) ((start) + (factor) * ((end) - (start)))

	/* more here */
#endif

#if !defined(CUTE_DSP_DEFINES)
	#define CUTE_DSP_DEFINES
	#define CUTE_DSP_MONO (1)
	#define CUTE_DSP_STEREO (2)
	#define CUTE_DSP_INVALID_PLUGIN_ID (-1)

	// default cutoff frequencies for LPF and HPF chosen 
	// such that their effect is inaudible (at the edges of human hearing)
	// unless changed
	#define CUTE_DSP_DEFAULT_HIGHPASS_CUTOFF (20.0f)
	#define CUTE_DSP_DEFAULT_LOWPASS_CUTOFF  (20000.0f)

	// rand max
	#define CUTE_DSP_PRNG_MAX ((size_t)(-1))

	#define CUTE_DSP_DB_TO_GAIN(db) (powf(10, db / 20.f))
	#define CUTE_DSP_GAIN_TO_DB(gain) (20.f * log10f(gain))
#endif
/* END HELPER MACROS */

/* BEGIN OPAQUE STRUCT IMPLEMENTATION */
typedef struct cd_memory_pool_object_t
{
	struct cd_memory_pool_object_t* next;
} cd_memory_pool_object_t;

typedef struct cd_memory_pool_t
{
	unsigned size_per_object;
	unsigned max_objects;
	unsigned pool_size;
	unsigned num_objects;
	char* pool;
	cd_memory_pool_object_t* free_list;
} cd_memory_pool_t;

typedef struct cd_memory_pool_def_t
{
	unsigned size_per_object;
	unsigned max_objects;
} cd_memory_pool_def_t;

typedef struct cd_ring_buffer_t
{
	float* buffer;
	int current_index;
	int max_elements;
} cd_ring_buffer_t;

// xorshift PRNG
typedef size_t uint64_t;
typedef struct cd_random_t
{
	uint64_t a;
	uint64_t b;
} cd_random_t;

typedef struct cd_context_t
{
	float sampling_rate;
	unsigned channel_count;
	cd_memory_pool_t lowpass_filters;
	cd_memory_pool_t highpass_filters;
	cd_memory_pool_t echo_filters;
	cd_memory_pool_t noise_generators;
	unsigned pool_size;
	cs_plugin_id_t lowpass_id;
	cs_plugin_id_t highpass_id;
	cs_plugin_id_t echo_id;
	cs_plugin_id_t noise_id;
	float* current_output;
	float output1[CUTE_DSP_MAX_FRAME_LENGTH * CUTE_DSP_STEREO]; // number of samples is frames * channels
	float output2[CUTE_DSP_MAX_FRAME_LENGTH * CUTE_DSP_STEREO];

	// optional filter default parameters
	float echo_max_delay_s;
	cd_random_t random_generator;

} cd_context_t;

static cd_context_t* g_dsp_context = 0;

typedef struct cd_lowpass_t
{
	struct cd_lowpass_t* next;
	float freq_cutoff;
	float sampling_rate;
	float y1;
	float y2;
	float x_coeff;
	float y1_coeff;
	float y2_coeff;
} cd_lowpass_t;

typedef struct cd_highpass_t
{
	struct cd_highpass_t* next;
	float freq_cutoff;
	float sampling_rate;
	float y1;
	float y2;
	float x1;
	float x2;
	float x_coeff;
	float x1_coeff;
	float y1_coeff;
	float y2_coeff;
} cd_highpass_t;

typedef struct cd_echo_t
{
	struct cd_echo_t* next;
	cd_ring_buffer_t xvalues;
	cd_ring_buffer_t yvalues;
	float mix;
	float feedback;
	float offset;
	float sampling_rate;
	float max_samples;
} cd_echo_t;

typedef struct cd_noise_t
{
	struct cd_noise_t* next;
	float amplitude_db;
	float amplitude_gain;
} cd_noise_t;

/* END OPAQUE STRUCT IMPLEMENTATION */
/* BEGIN FUNCTION IMPLEMENTATION */

/* BEGIN PLUGIN INTERFACE IMPLEMENTATION */
static cd_context_t* cd_get_context(void);

static void cd_lowpass_on_make_playing_sound(cs_context_t* cs_ctx, void* plugin_instance, void** playing_sound_udata, const cs_playing_sound_t* sound)
{
	cd_context_t* ctx = (cd_context_t*)plugin_instance;
	switch(sound->loaded_sound->channel_count)
	{
		case 1:
		{
			cd_lowpass_t* lowpass = cd_make_lowpass_filter(ctx);
			*playing_sound_udata = lowpass;
			break;
		}
		case 2:
		{
			cd_lowpass_t* lowpass = cd_make_lowpass_filter(ctx);
			*playing_sound_udata = lowpass;
			lowpass->next = cd_make_lowpass_filter(ctx);
			break;
		}
	}

	// unused parameters
	(void)cs_ctx;
	(void)sound;
}

static void cd_lowpass_on_free_playing_sound(cs_context_t* cs_ctx, void* plugin_instance, void* playing_sound_udata, const cs_playing_sound_t* sound)
{
	cd_context_t* ctx = (cd_context_t*)plugin_instance;
	cd_lowpass_t* filter = (cd_lowpass_t*)playing_sound_udata;
	if(filter->next)
	{
		cd_release_lowpass(ctx, &(filter->next));
	}
	cd_release_lowpass(ctx, &filter);

	// unused parameters
	(void)cs_ctx;
	(void)sound;
}

static void cd_lowpass_on_mix(cs_context_t* cs_ctx, void* plugin_instance, int channel_index, const float* samples_in, int sample_count, float** samples_out, void* playing_sound_udata, const cs_playing_sound_t* sound)
{
	cd_lowpass_t* filter = 0;
	cd_context_t* context = (cd_context_t*)plugin_instance;
	switch(channel_index)
	{
	case 0:
		filter = (cd_lowpass_t*)playing_sound_udata;
		break;
	case 1:
		filter = (cd_lowpass_t*)playing_sound_udata;
		filter = filter->next;
		break;
	}
	cd_sample_lowpass(context, filter, samples_in, samples_out, (unsigned)sample_count);

	// unused parameters
	(void)cs_ctx;
	(void)sound;
}

cs_plugin_interface_t cd_make_lowpass_plugin(void)
{
	cs_plugin_interface_t plugin;
	plugin.plugin_instance = cd_get_context();
	plugin.on_make_playing_sound_fn = cd_lowpass_on_make_playing_sound;
	plugin.on_free_playing_sound_fn = cd_lowpass_on_free_playing_sound;
	plugin.on_mix_fn = cd_lowpass_on_mix;

	return plugin;
}

static void cd_highpass_on_make_playing_sound(cs_context_t* cs_ctx, void* plugin_instance, void** playing_sound_udata, const cs_playing_sound_t* sound)
{
	cd_context_t* ctx = (cd_context_t*)plugin_instance;
	switch(sound->loaded_sound->channel_count)
	{
		case 1:
		{
			cd_highpass_t* filter = cd_make_highpass_filter(ctx);
			*playing_sound_udata = filter;
			break;
		}
		case 2:
		{
			cd_highpass_t* filter = cd_make_highpass_filter(ctx);
			*playing_sound_udata = filter;
			filter->next = cd_make_highpass_filter(ctx);
			break;
		}
	}
}

static void cd_highpass_on_free_playing_sound(cs_context_t* cs_ctx, void* plugin_instance, void* playing_sound_udata, const cs_playing_sound_t* sound)
{
	cd_context_t* ctx = (cd_context_t*)plugin_instance;
	cd_highpass_t* filter = (cd_highpass_t*)playing_sound_udata;
	if(filter->next)
	{
		cd_release_highpass(ctx, &(filter->next));
	}
	cd_release_highpass(ctx, &filter);
}

static void cd_highpass_on_mix(cs_context_t* cs_ctx, void* plugin_instance, int channel_index, const float* samples_in, int sample_count, float** samples_out, void* playing_sound_udata, const cs_playing_sound_t* sound)
{
	cd_highpass_t* filter = 0;
	cd_context_t* context = (cd_context_t*)plugin_instance;

	switch(channel_index)
	{
	case 0:
		filter = (cd_highpass_t*)playing_sound_udata;
		break;
	case 1:
		filter = (cd_highpass_t*)playing_sound_udata;
		filter = filter->next;
		break;
	}
	cd_sample_highpass(context, filter, samples_in, samples_out, (unsigned)sample_count);
}

cs_plugin_interface_t cd_make_highpass_plugin()
{
	cs_plugin_interface_t plugin;
	plugin.plugin_instance = cd_get_context();
	plugin.on_make_playing_sound_fn = cd_highpass_on_make_playing_sound;
	plugin.on_free_playing_sound_fn = cd_highpass_on_free_playing_sound;
	plugin.on_mix_fn = cd_highpass_on_mix;

	return plugin;
}

static void cd_echo_on_make_playing_sound(cs_context_t* cs_ctx, void* plugin_instance, void** playing_sound_udata, const cs_playing_sound_t* sound)
{
	cd_context_t* ctx = (cd_context_t*)plugin_instance;
	switch (sound->loaded_sound->channel_count)
	{
	case 1:
	{
		cd_echo_t* echo = cd_make_echo_filter(ctx);
		*playing_sound_udata = echo;
		break;
	}
	case 2:
	{
		cd_echo_t* echo = cd_make_echo_filter(ctx);
		*playing_sound_udata = echo;
		echo->next = cd_make_echo_filter(ctx);
		break;
	}
	}

	// unused parameters
	(void)cs_ctx;
	(void)sound;
}

static void cd_echo_on_free_playing_sound(cs_context_t* cs_ctx, void* plugin_instance, void* playing_sound_udata, const cs_playing_sound_t* sound)
{
	cd_context_t* ctx = (cd_context_t*)plugin_instance;
	cd_echo_t* filter = (cd_echo_t*)playing_sound_udata;
	if (filter->next)
	{
		cd_release_echo_filter(ctx, &(filter->next));
	}
	cd_release_echo_filter(ctx, &filter);

	// unused parameters
	(void)cs_ctx;
	(void)sound;
}

static void cd_echo_on_mix(cs_context_t* cs_ctx, void* plugin_instance, int channel_index, const float* samples_in, int sample_count, float** samples_out, void* playing_sound_udata, const cs_playing_sound_t* sound)
{
	cd_echo_t* filter = 0;
	cd_context_t* context = (cd_context_t*)plugin_instance;
	switch (channel_index)
	{
	case 0:
		filter = (cd_echo_t*)playing_sound_udata;
		break;
	case 1:
		filter = (cd_echo_t*)playing_sound_udata;
		filter = filter->next;
		break;
	}
	cd_sample_echo(context, filter, samples_in, samples_out, (unsigned)sample_count);

	// unused parameters
	(void)cs_ctx;
	(void)sound;
}

cs_plugin_interface_t cd_make_echo_plugin(void)
{
	cs_plugin_interface_t plugin;
	plugin.plugin_instance = cd_get_context();
	plugin.on_make_playing_sound_fn = cd_echo_on_make_playing_sound;
	plugin.on_free_playing_sound_fn = cd_echo_on_free_playing_sound;
	plugin.on_mix_fn = cd_echo_on_mix;

	return plugin;
}

static void cd_noise_on_make_playing_sound(cs_context_t* cs_ctx, void* plugin_instance, void** playing_sound_udata, const cs_playing_sound_t* sound)
{
	cd_context_t* ctx = (cd_context_t*)plugin_instance;
	switch (sound->loaded_sound->channel_count)
	{
	case 1:
	{
		cd_noise_t* noise = cd_make_noise_generator(ctx);
		*playing_sound_udata = noise;
		break;
	}
	case 2:
	{
		cd_noise_t* noise = cd_make_noise_generator(ctx);
		*playing_sound_udata = noise;
		noise->next = cd_make_noise_generator(ctx);
		break;
	}
	}

	// unused parameters
	(void)cs_ctx;
	(void)sound;
}

static void cd_noise_on_free_playing_sound(cs_context_t* cs_ctx, void* plugin_instance, void* playing_sound_udata, const cs_playing_sound_t* sound)
{
	cd_context_t* ctx = (cd_context_t*)plugin_instance;
	cd_noise_t* filter = (cd_noise_t*)playing_sound_udata;
	if (filter->next)
	{
		cd_release_noise(ctx, &(filter->next));
	}

	cd_release_noise(ctx, &filter);

	// unused parameters
	(void)cs_ctx;
	(void)sound;
}

static void cd_noise_on_mix(cs_context_t* cs_ctx, void* plugin_instance, int channel_index, const float* samples_in, int sample_count, float** samples_out, void* playing_sound_udata, const cs_playing_sound_t* sound)
{
	cd_noise_t* filter = 0;
	cd_context_t* context = (cd_context_t*)plugin_instance;
	switch (channel_index)
	{
	case 0:
		filter = (cd_noise_t*)playing_sound_udata;
		break;
	case 1:
		filter = (cd_noise_t*)playing_sound_udata;
		filter = filter->next;
		break;
	}
	cd_sample_noise(context, filter, samples_in, samples_out, (unsigned)sample_count);

	// unused parameters
	(void)cs_ctx;
	(void)sound;
}

cs_plugin_interface_t cd_make_noise_plugin(void)
{
	cs_plugin_interface_t plugin;
	plugin.plugin_instance = cd_get_context();
	plugin.on_make_playing_sound_fn = cd_noise_on_make_playing_sound;
	plugin.on_free_playing_sound_fn = cd_noise_on_free_playing_sound;
	plugin.on_mix_fn = cd_noise_on_mix;

	return plugin;
}

/* END PLUGIN INTERFACE IMPLEMENTATION */

/* BEGIN MEMORY POOL IMPLEMENTATION */
void cd_make_memory_pool(cd_memory_pool_t* mem_pool, cd_memory_pool_def_t def)
{
	char* pool = NULL;
	unsigned i = 0;

	CUTE_DSP_ASSERT(mem_pool);
	mem_pool->size_per_object = def.size_per_object;
	mem_pool->max_objects = def.max_objects;
	mem_pool->pool_size = def.max_objects * def.size_per_object;
	mem_pool->num_objects = 0;
	
	pool = CUTE_DSP_ALLOC(mem_pool->pool_size, 0);
	mem_pool->pool = pool;
	CUTE_DSP_ASSERT(pool);

	// initialize free list
	for(i = 0; i < def.max_objects; ++i)
	{
		cd_memory_pool_object_t* obj = (cd_memory_pool_object_t *)(mem_pool->pool + i * def.size_per_object);
		obj->next = mem_pool->free_list;
		mem_pool->free_list = obj;
	}
}

void cd_release_memory_pool(cd_memory_pool_t* mem_pool)
{
	CUTE_DSP_ASSERT(mem_pool);
	if(mem_pool->pool)
	{
		CUTE_DSP_FREE(mem_pool->pool, 0);
		mem_pool->pool = NULL;
	}
}

void* cd_memory_pool_alloc(cd_memory_pool_t* mem_pool)
{
	CUTE_DSP_ASSERT(mem_pool);

	// case the pool is empty
	if(mem_pool->free_list == NULL)
	{
		// allocate from the heap normally
		void* object = CUTE_DSP_ALLOC(mem_pool->size_per_object, 0);
		CUTE_DSP_ASSERT(object);
		++mem_pool->num_objects;
		return object;
	}
	else
	{
		// pull another object from the free list
		cd_memory_pool_object_t* object = mem_pool->free_list;
		mem_pool->free_list = mem_pool->free_list->next;
		++mem_pool->num_objects;
		return object;
	}
}

void cd_memory_pool_free(cd_memory_pool_t* mem_pool, void* object)
{
	char* obj = (char *)object;
	size_t obj_distance, pool_distance;
	CUTE_DSP_ASSERT(object && mem_pool);

	obj_distance = obj - mem_pool->pool;
	pool_distance = (mem_pool->pool + mem_pool->pool_size) - mem_pool->pool;

	// case object isn't in the pool
	if(pool_distance < obj_distance && obj_distance >= 0)
	{
		CUTE_DSP_FREE(object, 0);
	}
	// case object is in the pool
	else
	{
		// put it back on the free list
		cd_memory_pool_object_t* mem_obj = (cd_memory_pool_object_t*)(object);
		mem_obj->next = mem_pool->free_list;
		mem_pool->free_list = mem_obj;
	}
	
	--mem_pool->num_objects;
}
/* END MEMORY POOL IMPLEMENTATION */

/* BEGIN RING BUFFER IMPLEMENTATION */

void cd_ring_buffer_init(cd_ring_buffer_t* buff, int num_elements)
{
	if (num_elements)
	{
		buff->buffer = (float*)CUTE_DSP_ALLOC((sizeof(float) * num_elements), 0);
		buff->current_index = 0;
		buff->max_elements = num_elements;
		memset(buff->buffer, 0, sizeof(float) * num_elements);
	}
	else
	{
		buff->buffer = 0;
		buff->current_index = 0;
		buff->max_elements = 0;
	}
}

inline void cd_ring_buffer_put(cd_ring_buffer_t* buff, float value)
{
	buff->buffer[buff->current_index] = value;
	buff->current_index = (buff->current_index + 1) % buff->max_elements;
}

inline float cd_ring_buffer_get(cd_ring_buffer_t* buff, int delay)
{
	int index = buff->current_index - delay - 1;
	index %= buff->max_elements;
	if (index < 0) index += buff->max_elements;
	return buff->buffer[index];
}

void cd_ring_buffer_release(cd_ring_buffer_t* buff)
{
	CUTE_DSP_ASSERT(buff);
	if(buff->buffer)
		CUTE_DSP_FREE(buff->buffer, 0);
	buff->buffer = 0;
	buff->current_index = 0;
	buff->max_elements = 0;
}

/* END RING BUFFER IMPLEMENTATION */

/* BEGIN RANDOM IMPLEMENTATION */

void cd_random_seed(cd_random_t* prng, uint64_t seed)
{
	prng->a = seed / 2;
	prng->b = seed;
}

uint64_t cd_random_rand(cd_random_t* prng)
{
	uint64_t t = prng->a;
	uint64_t const s = prng->b;
	prng->a = s;
	t ^= t << 23;
	t ^= t >> 17;
	t ^= s ^ (s >> 26);
	prng->b = t;
	return t + s;
}

float cd_random_rand_between(cd_random_t* prng, float min_val, float max_val)
{
	uint64_t raw = cd_random_rand(prng);
	double scale = (double)raw / (double)CUTE_DSP_PRNG_MAX;
	return (float)((double)min_val + scale * ((double)max_val - (double)min_val));
}

/* END RANDOM IMPLEMENTATION */

/* BEGIN CONTEXT IMPLEMENTATION */
static cd_context_t* cd_get_context(void)
{
	return g_dsp_context;
}

#define cd_context_swap_buffers(context)	\
{	\
	if (context->current_output == context->output1)	\
	{	\
		context->current_output = context->output2;	\
	}	\
	else	\
	{	\
		context->current_output = context->output1;	\
	}	\
}

cd_context_t* cd_make_context(cs_context_t* sound_ctx, cd_context_def_t def)
{
	cd_memory_pool_def_t lowpass_def;
	cd_memory_pool_def_t highpass_def;
	cd_memory_pool_def_t echo_def;
	cd_memory_pool_def_t noise_def;

	cd_context_t* context = (cd_context_t *)CUTE_DSP_ALLOC(sizeof(cd_context_t), 0);
	CUTE_DSP_ASSERT(context && def.playing_pool_count);
	g_dsp_context = context;

	context->sampling_rate = def.sampling_rate;
	context->pool_size = def.playing_pool_count * 2;
	context->channel_count = CUTE_DSP_STEREO;
	memset(context->output1, 0, sizeof(float) * CUTE_DSP_MAX_FRAME_LENGTH);
	memset(context->output2, 0, sizeof(float) * CUTE_DSP_MAX_FRAME_LENGTH);
	context->current_output = context->output1;

	/* set up filters =========================================== */
	/* noise filter */
	if (def.use_noise)
	{
		noise_def.max_objects = context->pool_size;
		noise_def.size_per_object = sizeof(cd_noise_t);
		cd_make_memory_pool(&context->noise_generators, noise_def);

		cs_plugin_interface_t noise_interface = cd_make_noise_plugin();
		context->noise_id = cs_add_plugin(sound_ctx, &noise_interface);

		cd_random_seed(&context->random_generator, def.rand_seed);
	}
	else
	{
		memset(&context->noise_generators, 0, sizeof(cd_memory_pool_t));
		context->noise_id = CUTE_DSP_INVALID_PLUGIN_ID;
	}

	/* lowpass filter */
	if(def.use_lowpass)
	{
		lowpass_def.max_objects = context->pool_size;
		lowpass_def.size_per_object = sizeof(cd_lowpass_t);
		cd_make_memory_pool(&context->lowpass_filters, lowpass_def);

		cs_plugin_interface_t lowpass_interface = cd_make_lowpass_plugin();
		context->lowpass_id = cs_add_plugin(sound_ctx, &lowpass_interface);
	}
	else
	{
		memset(&context->lowpass_filters, 0, sizeof(cd_memory_pool_t));
		context->lowpass_id = CUTE_DSP_INVALID_PLUGIN_ID;
	}

	/* highpass filter */
	if(def.use_highpass)
	{
		highpass_def.max_objects = context->pool_size;
		highpass_def.size_per_object = sizeof(cd_highpass_t);
		cd_make_memory_pool(&context->highpass_filters, highpass_def);

		cs_plugin_interface_t highpass_interface = cd_make_highpass_plugin();
		context->highpass_id = cs_add_plugin(sound_ctx, &highpass_interface);
	}
	else
	{
		memset(&context->highpass_filters, 0, sizeof(cd_memory_pool_t));
		context->highpass_id = CUTE_DSP_INVALID_PLUGIN_ID;
	}

	/* echo filter */
	if (def.use_echo)
	{
		echo_def.max_objects = context->pool_size;
		echo_def.size_per_object = sizeof(cd_echo_t);
		cd_make_memory_pool(&context->echo_filters, echo_def);
		
		cs_plugin_interface_t echo_interface = cd_make_echo_plugin();
		context->echo_id = cs_add_plugin(sound_ctx, &echo_interface);

		if (def.echo_max_delay_s == 0.f)
			context->echo_max_delay_s = CUTE_DSP_DEFAULT_ECHO_MAX_DELAY;
		else
			context->echo_max_delay_s = def.echo_max_delay_s;
	}
	else
	{
		memset(&context->echo_filters, 0, sizeof(cd_memory_pool_t));
		context->echo_id = CUTE_DSP_INVALID_PLUGIN_ID;
	}

	return context;
}

void cd_release_context(cd_context_t** context)
{
	CUTE_DSP_ASSERT(context && *context);

	if((*context)->lowpass_id != CUTE_DSP_INVALID_PLUGIN_ID)
		cd_release_memory_pool(&(*context)->lowpass_filters);
	if ((*context)->highpass_id!= CUTE_DSP_INVALID_PLUGIN_ID)
		cd_release_memory_pool(&(*context)->highpass_filters);
	if ((*context)->echo_id != CUTE_DSP_INVALID_PLUGIN_ID)
		cd_release_memory_pool(&(*context)->echo_filters);
	if ((*context)->noise_id != CUTE_DSP_INVALID_PLUGIN_ID)
		cd_release_memory_pool(&(*context)->noise_generators);

	CUTE_DSP_FREE(*context, 0);
	*context = 0;
	g_dsp_context = 0;
}

/* END CONTEXT IMPLEMENTATION */

/* BEGIN LOWPASS IMPLEMENTATION */
cd_lowpass_t* cd_make_lowpass_filter(cd_context_t* context)
{
	cd_lowpass_t* filter = NULL;
	CUTE_DSP_ASSERT(context);

	filter = (cd_lowpass_t*)cd_memory_pool_alloc(&context->lowpass_filters);
	CUTE_DSP_ASSERT(filter);

	filter->sampling_rate = context->sampling_rate;
	cd_set_lowpass_cutoff_frequency(filter, CUTE_DSP_DEFAULT_LOWPASS_CUTOFF);
	filter->y1 = filter->y2 = 0.f;
	filter->next = 0;
	return filter;
}

void cd_release_lowpass(cd_context_t* context, cd_lowpass_t** filter)
{
	CUTE_DSP_ASSERT(filter && *filter);
	cd_memory_pool_free(&context->lowpass_filters, *filter);
	*filter = NULL;
}

static void cd_set_lowpass_cutoff_frequency_radians(cd_lowpass_t* filter, float cutoff_freq_in_rad)
{
	float T = cutoff_freq_in_rad / filter->sampling_rate;
	float Y = 1.f / (1.f + CUTE_DSP_SQRT_2 * T + T * T);
	filter->x_coeff  = T * T * Y;
	filter->y1_coeff = (2.f + CUTE_DSP_SQRT_2 * T) * Y;
	filter->y2_coeff = -1.f * Y;
}

void cd_set_lowpass_cutoff_frequency(cd_lowpass_t* filter, float cutoff_freq_in_hz)
{
	filter->freq_cutoff = cutoff_freq_in_hz;
	float freq_in_rad = 2.f * CUTE_DSP_PI * cutoff_freq_in_hz;

	cd_set_lowpass_cutoff_frequency_radians(filter, freq_in_rad);
	if(filter->next)
	{
		cd_set_lowpass_cutoff_frequency_radians(filter->next, freq_in_rad);
	}
}

void cd_set_lowpass_cutoff(cs_playing_sound_t* playing_sound, float cutoff_freq_in_hz)
{
	CUTE_DSP_ASSERT(playing_sound);
	cd_context_t* ctx = cd_get_context();
	CUTE_DSP_ASSERT(ctx->lowpass_id != CUTE_DSP_INVALID_PLUGIN_ID);

	cd_lowpass_t* filter = (cd_lowpass_t*)playing_sound->plugin_udata[ctx->lowpass_id];
	cd_set_lowpass_cutoff_frequency(filter, cutoff_freq_in_hz);
}

float cd_get_lowpass_cutoff_frequency(const cd_lowpass_t* filter)
{
	return filter->freq_cutoff;
}

float cd_get_lowpass_cutoff(const cs_playing_sound_t* playing_sound)
{
	CUTE_DSP_ASSERT(playing_sound);
	cd_context_t* ctx = cd_get_context();
	CUTE_DSP_ASSERT(ctx->lowpass_id != CUTE_DSP_INVALID_PLUGIN_ID);

	const cd_lowpass_t* filter = (const cd_lowpass_t*)playing_sound->plugin_udata[ctx->lowpass_id];
	return cd_get_lowpass_cutoff_frequency(filter);
}

void cd_sample_lowpass(cd_context_t* context, cd_lowpass_t* filter, const float* input, float** output, unsigned num_samples)
{
	int i = 0; 
	float* samples = context->current_output;
	//memset(samples, 0, sizeof(float) * CUTE_DSP_MAX_FRAME_LENGTH);

	for(; i < (int)num_samples; ++i)
	{
		*samples = filter->x_coeff * *input++ + 
					filter->y1_coeff * filter->y1 + 
					filter->y2_coeff * filter->y2;
		filter->y2 = filter->y1;
		filter->y1 = *samples++;
	}

	*output = context->current_output;
	cd_context_swap_buffers(context);
}
/* END LOWPASS IMPLEMENTATION */

/* BEGIN HIGHPASS IMPLEMENTATION */
cd_highpass_t* cd_make_highpass_filter(cd_context_t* context)
{
	cd_highpass_t* filter = NULL;
	CUTE_DSP_ASSERT(context);

	filter = (cd_highpass_t*)cd_memory_pool_alloc(&context->highpass_filters);
	CUTE_DSP_ASSERT(filter);

	filter->sampling_rate = context->sampling_rate;
	cd_set_highpass_cutoff_frequency(filter, CUTE_DSP_DEFAULT_HIGHPASS_CUTOFF);
	filter->x1 = filter->x2 = filter->y1 = filter->y2 = 0;
	filter->next = 0;
	return filter;
}

void cd_release_highpass(cd_context_t* context, cd_highpass_t** filter)
{
	CUTE_DSP_ASSERT(context && filter && *filter);
	cd_memory_pool_free(&context->highpass_filters, *filter);
	*filter = NULL;
}

static void cd_set_highpass_cutoff_frequency_radians(cd_highpass_t* filter, float cutoff_freq_in_rad)
{
	float T = cutoff_freq_in_rad / filter->sampling_rate;
	float Y = 1.f / (1 + CUTE_DSP_SQRT_2 * T + T * T);
	filter->x_coeff = Y;
	filter->x1_coeff = -2.f * Y;
	filter->y1_coeff = (2.f + CUTE_DSP_SQRT_2 * T) * Y;
	filter->y2_coeff = -Y;
}

void cd_set_highpass_cutoff_frequency(cd_highpass_t* filter, float cutoff_freq_in_hz)
{
	filter->freq_cutoff = cutoff_freq_in_hz;
	float freq_in_rad = 2.f * CUTE_DSP_PI * cutoff_freq_in_hz;

	cd_set_highpass_cutoff_frequency_radians(filter, freq_in_rad);
	if(filter->next)
	{
		cd_set_highpass_cutoff_frequency_radians(filter->next, freq_in_rad);
	}
}

void cd_set_highpass_cutoff(cs_playing_sound_t* playing_sound, float cutoff_freq_in_hz)
{
	CUTE_DSP_ASSERT(playing_sound);
	cd_context_t* ctx = cd_get_context();
	CUTE_DSP_ASSERT(ctx->highpass_id != CUTE_DSP_INVALID_PLUGIN_ID);

	cd_highpass_t* filter = (cd_highpass_t*)playing_sound->plugin_udata[ctx->highpass_id];
	cd_set_highpass_cutoff_frequency(filter, cutoff_freq_in_hz);
}

float cd_get_highpass_cutoff_frequency(const cd_highpass_t* filter)
{
	return filter->freq_cutoff;
}

float cd_get_highpass_cutoff(const cs_playing_sound_t* playing_sound)
{
	CUTE_DSP_ASSERT(playing_sound);
	cd_context_t* ctx = cd_get_context();
	CUTE_DSP_ASSERT(ctx->highpass_id != CUTE_DSP_INVALID_PLUGIN_ID);

	const cd_highpass_t* filter = (const cd_highpass_t*)playing_sound->plugin_udata[ctx->highpass_id];
	return cd_get_highpass_cutoff_frequency(filter);
}

void cd_sample_highpass(cd_context_t* context, cd_highpass_t* filter, const float* input, float** output, unsigned num_samples)
{
	unsigned i = 0;
	float* samples = context->current_output;

	for(; i < num_samples; ++i)
	{
		*samples = filter->x_coeff  * *input +
					filter->x1_coeff * filter->x1 +
					filter->x_coeff  * filter->x2 +
					filter->y1_coeff * filter->y1 +
					filter->y2_coeff * filter->y2;
		filter->x2 = filter->x1;
		filter->x1 = *input++;
		filter->y2 = filter->y1;
		filter->y1 = *samples++;
	}

	*output = context->current_output;
	cd_context_swap_buffers(context);
}
/* END HIGHPASS IMPLEMENTATION */

/* BEGIN ECHO IMPLEMENTATION */

cd_echo_t* cd_make_echo_filter(cd_context_t* context)
{
	cd_echo_t* filter = NULL;
	CUTE_DSP_ASSERT(context);

	filter = (cd_echo_t*)cd_memory_pool_alloc(&context->echo_filters);
	CUTE_DSP_ASSERT(filter);

	filter->sampling_rate = context->sampling_rate;
	filter->max_samples = context->echo_max_delay_s * filter->sampling_rate;
	filter->feedback = 0.f;
	filter->offset = 0.f;
	filter->mix = 0.f;
	cd_ring_buffer_init(&filter->xvalues, (int)filter->max_samples);
	cd_ring_buffer_init(&filter->yvalues, (int)filter->max_samples);
	filter->next = NULL;

	return filter;
}

void cd_release_echo_filter(cd_context_t* context, cd_echo_t** filter)
{
	CUTE_DSP_ASSERT(context && filter && *filter);
	cd_ring_buffer_release(&(*filter)->xvalues);
	cd_ring_buffer_release(&(*filter)->yvalues);
	cd_memory_pool_free(&context->echo_filters, *filter);
	*filter = NULL;
}

void cd_set_echo_delay(cs_playing_sound_t* playing_sound, float t)
{
	CUTE_DSP_ASSERT(playing_sound);
	cd_context_t* ctx = cd_get_context();
	CUTE_DSP_ASSERT(ctx->echo_id != CUTE_DSP_INVALID_PLUGIN_ID);
	if (t > ctx->echo_max_delay_s) return;
	cd_echo_t* filter = (cd_echo_t*)playing_sound->plugin_udata[ctx->echo_id];
	filter->offset = t * filter->sampling_rate;
}

void cd_set_echo_mix(cs_playing_sound_t* playing_sound, float a)
{
	CUTE_DSP_ASSERT(playing_sound);
	cd_context_t* ctx = cd_get_context();
	CUTE_DSP_ASSERT(ctx->echo_id != CUTE_DSP_INVALID_PLUGIN_ID);

	cd_echo_t* filter = (cd_echo_t*)playing_sound->plugin_udata[ctx->echo_id];
	filter->mix = a;
}

void cd_set_echo_feedback(cs_playing_sound_t* playing_sound, float b)
{
	CUTE_DSP_ASSERT(playing_sound);
	cd_context_t* ctx = cd_get_context();
	CUTE_DSP_ASSERT(ctx->echo_id != CUTE_DSP_INVALID_PLUGIN_ID);

	cd_echo_t* filter = (cd_echo_t*)playing_sound->plugin_udata[ctx->echo_id];
	filter->feedback = b;
}

float cd_get_echo_delay(const cs_playing_sound_t* playing_sound)
{
	CUTE_DSP_ASSERT(playing_sound);
	cd_context_t* ctx = cd_get_context();
	CUTE_DSP_ASSERT(ctx->echo_id != CUTE_DSP_INVALID_PLUGIN_ID);

	const cd_echo_t* filter = (cd_echo_t*)playing_sound->plugin_udata[ctx->echo_id];
	return filter->offset / filter->sampling_rate;
}

float cd_get_echo_mix(const cs_playing_sound_t* playing_sound)
{
	CUTE_DSP_ASSERT(playing_sound);
	cd_context_t* ctx = cd_get_context();
	CUTE_DSP_ASSERT(ctx->echo_id != CUTE_DSP_INVALID_PLUGIN_ID);

	const cd_echo_t* filter = (cd_echo_t*)playing_sound->plugin_udata[ctx->echo_id];
	return filter->mix;
}

float cd_get_echo_feedback(const cs_playing_sound_t* playing_sound)
{
	CUTE_DSP_ASSERT(playing_sound);
	cd_context_t* ctx = cd_get_context();
	CUTE_DSP_ASSERT(ctx->echo_id != CUTE_DSP_INVALID_PLUGIN_ID);

	const cd_echo_t* filter = (cd_echo_t*)playing_sound->plugin_udata[ctx->echo_id];
	return filter->feedback;
}

float cd_get_echo_max_delay(const cs_playing_sound_t* playing_sound)
{
	CUTE_DSP_ASSERT(playing_sound);
	cd_context_t* ctx = cd_get_context();
	(void)playing_sound; /* unused parameter */
	return ctx->echo_max_delay_s;
}

void cd_sample_echo(cd_context_t* context, cd_echo_t* filter, const float* input, float** output, unsigned num_samples)
{
	int i = 0; 
	float* samples = context->current_output;
	float out;
	float startInd, endInd, factor;
	float ystart, yend, yresult;
	float xstart, xend, xresult;
	for (; i < (int)num_samples; ++i)
	{
		out = *input;
		startInd = (float)(int)filter->offset; // floor
		endInd = startInd + 1;
		factor = filter->offset - startInd;

		ystart = cd_ring_buffer_get(&filter->yvalues, (int)startInd);
		yend = cd_ring_buffer_get(&filter->yvalues, (int)endInd);
		yresult = CUTE_DSP_LERP_FLOAT(ystart, yend, (int)factor);

		xstart = cd_ring_buffer_get(&filter->xvalues, (int)startInd);
		xend = cd_ring_buffer_get(&filter->xvalues, (int)endInd);
		xresult = CUTE_DSP_LERP_FLOAT(xstart, xend, factor);

		out += (filter->mix - filter->feedback) * xresult + filter->feedback * yresult;

		cd_ring_buffer_put(&filter->yvalues, out);
		cd_ring_buffer_put(&filter->xvalues, *input++);

		*samples++ = out;
	}
	
	*output = context->current_output;
	cd_context_swap_buffers(context);
}
/* END ECHO IMPLEMENTATION */

/* BEGIN NOISE IMPLEMENTATION */
cd_noise_t* cd_make_noise_generator(cd_context_t* context)
{
	cd_noise_t* filter = NULL;
	CUTE_DSP_ASSERT(context);

	filter = (cd_noise_t*)cd_memory_pool_alloc(&context->noise_generators);
	CUTE_DSP_ASSERT(filter);

	filter->amplitude_db = CUTE_DSP_NOISE_INAUDIBLE;
	filter->amplitude_gain = CUTE_DSP_DB_TO_GAIN(filter->amplitude_db);
	filter->next = 0;
	return filter;
}

void cd_release_noise(cd_context_t* context, cd_noise_t** filter)
{
	CUTE_DSP_ASSERT(context && filter && *filter);
	cd_memory_pool_free(&context->noise_generators, *filter);
	*filter = NULL;
}

void cd_set_noise_amplitude_db(cs_playing_sound_t* playing_sound, float db)
{
	CUTE_DSP_ASSERT(playing_sound);
	cd_context_t* ctx = cd_get_context();
	CUTE_DSP_ASSERT(ctx->noise_id != CUTE_DSP_INVALID_PLUGIN_ID);
	cd_noise_t* filter = (cd_noise_t*)playing_sound->plugin_udata[ctx->noise_id];
	filter->amplitude_db = db;
	filter->amplitude_gain = CUTE_DSP_DB_TO_GAIN(db);
}

void cd_set_noise_amplitude_gain(cs_playing_sound_t* playing_sound, float gain)
{
	CUTE_DSP_ASSERT(playing_sound);
	cd_context_t* ctx = cd_get_context();
	CUTE_DSP_ASSERT(ctx->noise_id != CUTE_DSP_INVALID_PLUGIN_ID);
	cd_noise_t* filter = (cd_noise_t*)playing_sound->plugin_udata[ctx->noise_id];
	filter->amplitude_gain = gain;
	filter->amplitude_db = CUTE_DSP_GAIN_TO_DB(gain);
}

float cd_get_noise_amplitude_db(const cs_playing_sound_t* playing_sound)
{
	CUTE_DSP_ASSERT(playing_sound);
	cd_context_t* ctx = cd_get_context();
	CUTE_DSP_ASSERT(ctx->noise_id != CUTE_DSP_INVALID_PLUGIN_ID);
	cd_noise_t* filter = (cd_noise_t*)playing_sound->plugin_udata[ctx->noise_id];
	return filter->amplitude_db;
}

float cd_get_noise_amplitude_gain(const cs_playing_sound_t* playing_sound)
{
	CUTE_DSP_ASSERT(playing_sound);
	cd_context_t* ctx = cd_get_context();
	CUTE_DSP_ASSERT(ctx->noise_id != CUTE_DSP_INVALID_PLUGIN_ID);
	cd_noise_t* filter = (cd_noise_t*)playing_sound->plugin_udata[ctx->noise_id];
	return filter->amplitude_gain;
}

void cd_sample_noise(cd_context_t* context, cd_noise_t* filter, const float* input, float** output, unsigned num_samples)
{
	unsigned i = 0;
	float* samples = context->current_output;
	cd_random_t* random = &context->random_generator;
	float amplitude = filter->amplitude_gain;

	for (; i < num_samples; ++i)
	{
		*samples++ = amplitude * cd_random_rand_between(random, -1.f, 1.f) + *input++;
	}

	*output = context->current_output;
	cd_context_swap_buffers(context);
}
/* END NOISE IMPLEMENTATION */

/* END FUNCTION IMPLEMENTATION */

#endif /* CUTE_DSP_IMPLEMENTATION_ONCE */
#endif /* CUTE_DSP_IMPLEMENTATION */
/* END IMPLEMENTATION SECTION */

/*
	------------------------------------------------------------------------------
	This software is available under 2 licenses - you may choose the one you like.
	------------------------------------------------------------------------------
	ALTERNATIVE A - zlib license
	Copyright (c) 2019 Matthew Rosen
	This software is provided 'as-is', without any express or implied warranty.
	In no event will the authors be held liable for any damages arising from
	the use of this software.
	Permission is granted to anyone to use this software for any purpose,
	including commercial applications, and to alter it and redistribute it
	freely, subject to the following restrictions:
	  1. The origin of this software must not be misrepresented; you must not
		 claim that you wrote the original software. If you use this software
		 in a product, an acknowledgment in the product documentation would be
		 appreciated but is not required.
	  2. Altered source versions must be plainly marked as such, and must not
		 be misrepresented as being the original software.
	  3. This notice may not be removed or altered from any source distribution.
	------------------------------------------------------------------------------
	ALTERNATIVE B - Public Domain (www.unlicense.org)
	This is free and unencumbered software released into the public domain.
	Anyone is free to copy, modify, publish, use, compile, sell, or distribute this
	software, either in source code form or as a compiled binary, for any purpose,
	commercial or non-commercial, and by any means.
	In jurisdictions that recognize copyright laws, the author or authors of this
	software dedicate any and all copyright interest in the software to the public
	domain. We make this dedication for the benefit of the public at large and to
	the detriment of our heirs and successors. We intend this dedication to be an
	overt act of relinquishment in perpetuity of all present and future rights to
	this software under copyright law.
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
	ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
	WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	------------------------------------------------------------------------------
*/
